labelmat.tree_col = intersect(colnames(labelmat.tree.i), colnames(labelmat.tree))
labelmat.tree_col = labelmat.tree_col[as.numeric(labelmat.tree_col) %in% ks]
stab.tree = rep(NA, length(ks)); names(stab.tree) = as.character(ks)
stab.tree[labelmat.tree_col] = get_index_per_layer(labelmat1 = labelmat.tree.i[,labelmat.tree_col],
labelmat2 = labelmat.tree[,labelmat.tree_col], index.name='ari')
return(list(stab.flat=stab.flat, stab.tree=stab.tree))
})
stab.flat = colMeans(do.call(rbind,lapply(stab.out, function(x) x$stab.flat)))
stab.mrtree = colMeans(do.call(rbind,lapply(stab.out, function(x) x$stab.tree)))
stab = data.frame(flat = stab.flat, mrtree = stab.mrtree)
return(list(acc=acc, tree.diff=tree.diff, stab = stab))
},mc.cores = n.cores) #
## visualize the results
res = readRDS(paste0(result.path, 'out_seurat_sigma', sigma_name, suffix,'.rds'))
acc.flat = do.call(cbind, lapply(res, function(x)  x$acc$flat))
acc.mrtree = do.call(cbind, lapply(res, function(x) x$acc$mrtree))
df = rbind(data.frame(acc = c(acc.flat), k = rep(ks, nrep), method='Seurat'),
data.frame(acc = c(acc.mrtree), k = rep(ks, nrep), method='MrTree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = acc, fill = method)) + geom_boxplot()+ylab('AMRI') +theme(text = element_text(size=20))+ylim(0.8,1)
# compare the tree reconstruction accuracy
df = data.frame(tree.diff = c(
# sapply(res, function(x) x$tree.diff$flat),
sapply(res, function(x) x$tree.diff$mrtree),
sapply(res, function(x) x$tree.diff$hc)),
method = rep(c('MrTree', paste0('Seurat HAC')), each = nrep))
options(repr.plot.width = 4, repr.plot.height = 3)
ggplot(df, aes(x = method, y=tree.diff)) + geom_boxplot()+ylab('Error') +ylim(0,0.4)
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$kway))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$recon))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='Seurat'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$flat))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$recon))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='Seurat'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
str(stab.flat)
str(stab.mrtree)
str(res)
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$mrtree))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='Seurat'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = stab, fill = method)) + geom_boxplot()+ylab('Stability v.s. true label')  #+ylim(0.2,1)
## visualize the results
res = readRDS(paste0(result.path, 'out_sc3_sigma', sigma_name, suffix,'.rds'))
acc.flat = do.call(cbind, lapply(res, function(x)  x$acc$flat))
acc.mrtree = do.call(cbind, lapply(res, function(x) x$acc$mrtree))
df = rbind(data.frame(acc = c(acc.flat), k = rep(ks, nrep), method='Seurat'),
data.frame(acc = c(acc.mrtree), k = rep(ks, nrep), method='MrTree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = acc, fill = method)) + geom_boxplot()+ylab('AMRI') +theme(text = element_text(size=20))+ylim(0.8,1)
# compare the tree reconstruction accuracy
df = data.frame(tree.diff = c(
# sapply(res, function(x) x$tree.diff$flat),
sapply(res, function(x) x$tree.diff$mrtree),
sapply(res, function(x) x$tree.diff$hc)),
method = rep(c('MrTree', paste0('SC3 HAC')), each = nrep))
options(repr.plot.width = 4, repr.plot.height = 3)
ggplot(df, aes(x = method, y=tree.diff)) + geom_boxplot()+ylab('Error') +ylim(0,0.4)
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$kway))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$recon))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='SC3'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$flat))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$mrtree))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='SC3'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = stab, fill = method)) + geom_boxplot()+ylab('Stability v.s. true label')  #+ylim(0.2,1)
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='SC3'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = stab, fill = method)) + geom_boxplot()+ylab('Stability v.s. true label')  #+ylim(0.2,1)
## visualize the results
res = readRDS(paste0(result.path, 'out_umapkmeans_sigma', sigma_name, suffix,'.rds'))
acc.flat = do.call(cbind, lapply(res, function(x)  x$acc$flat))
acc.mrtree = do.call(cbind, lapply(res, function(x) x$acc$mrtree))
df = rbind(data.frame(acc = c(acc.flat), k = rep(ks, nrep), method='UMAP+Kmeans'),
data.frame(acc = c(acc.mrtree), k = rep(ks, nrep), method='MrTree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = acc, fill = method)) + geom_boxplot()+ylab('AMRI') +theme(text = element_text(size=20))+ylim(0.8,1)
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$flat))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$mrtree))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='UMAP+Kmeans'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
df =df[df$k <=8,]
df$k = as.factor(df$k)
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = stab, fill = method)) + geom_boxplot()+ylab('Stability v.s. true label')  #+ylim(0.2,1)
## visualize the results
res = readRDS(paste0(result.path, 'out_soup_sigma', sigma_name, suffix,'.rds'))
acc.flat = do.call(cbind, lapply(res, function(x)  x$acc$flat))
acc.mrtree = do.call(cbind, lapply(res, function(x) x$acc$mrtree))
df = rbind(data.frame(acc = c(acc.flat), k = rep(ks, nrep), method='SOUP'),
data.frame(acc = c(acc.mrtree), k = rep(ks, nrep), method='MrTree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = acc, fill = method)) + geom_boxplot()+ylab('AMRI') +theme(text = element_text(size=20))+ylim(0.8,1)
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$flat))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$mrtree))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='SOUP'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = stab, fill = method)) + geom_boxplot()+ylab('Stability v.s. true label')  #+ylim(0.2,1)
devtools::load_all()
labelmat = matrix(NA, nrow=200, ncol=7)
labelmat[1:100,1] = 1; labelmat[101:200,1] = 2
labelmat[1:50, 2] = 1; labelmat[51:100, 2] = 2; labelmat[101:200, 2] = 3
labelmat[1:50, 3] = 1; labelmat[51:100, 3] = 2; labelmat[101:200, 3] = 3
labelmat[1:100,4] = 1;  labelmat[101:150, 4] = 2;  labelmat[151:200, 4] = 3
labelmat[1:50, 5] = 1; labelmat[51:100, 5] = 2; labelmat[101:200, 5] = 3
labelmat[1:50, 6] = 1; labelmat[51:100, 6] = 2; labelmat[101:200, 6] = 3
labelmat[1:50, 7] = 1; labelmat[51:100, 7] = 2;  labelmat[101:150, 7] = 3; labelmat[151:200, 7] = 4
colnames(labelmat) = paste0('col', 1:7)
out = mrtree(labelmat, max.k=Inf, consensus=F, sample.weighted=F, verbose=F)
#####################
# results
plot_clustree(labelmat, prefix ='col', cell.type = NULL, plot.labels = F)
plot_clustree(out$labelmat.recon, prefix ='col', cell.type = NULL, plot.labels = F)
#####################
# results
plot_clustree(labelmat, prefix ='col', cell.type = NULL, plot.labels = F)
plot_clustree(out$labelmat.recon, prefix ='col', cell.type = NULL, plot.labels = F)
out = mrtree(labelmat, max.k=Inf, aug.path=T, consensus=F, sample.weighted=F, verbose=F)
out = mrtree(labelmat, max.k=Inf, augment.path = T, consensus=F, sample.weighted=F, verbose=F)
#####################
# results
plot_clustree(labelmat, prefix ='col', cell.type = NULL, plot.labels = F)
plot_clustree(out$labelmat.recon, prefix ='col', cell.type = NULL, plot.labels = F)
paste0(result.path, 'out_seurat_sigma', sigma_name, suffix,'.rds')
source('~/Dropbox/research/MRtree/code/mrtree/R/simulations/simulation2.R', echo=TRUE)
paste0(result.path, 'out_seurat_sigma', sigma_name, suffix,'.rds')
realdata_geschwind_label_results <- readRDS("~/Dropbox/research/MRtree/code/analysis/realdata/results-geschwind/realdata_geschwind_label_results.rds")
str(realdata_geschwind_label_results)
getwd()
write.xlsx(realdata_geschwind_label_results, 'fetal_brain_labels.xlsx', sheetName = "Sheet1",
col.names = TRUE, row.names = TRUE, append = FALSE)
xlsx::write.xlsx(realdata_geschwind_label_results, 'fetal_brain_labels.xlsx', sheetName = "Sheet1",
col.names = TRUE, row.names = TRUE, append = FALSE)
xlsx::write.xlsx2(realdata_geschwind_label_results, 'fetal_brain_labels.xlsx', sheetName = "Sheet1",
col.names = TRUE, row.names = TRUE, append = FALSE)
write.table(realdata_geschwind_label_results, 'fetal_brain_labels.xlsx')
install.packages("writexl")
writexl::write_xlsx(realdata_geschwind_label_results,"fetal_brain_labels.xlsx")
devtools::load_all()
# The data simulation can be performed using SymSim package with the following wrapper function,
# The following simulation code take some time to run (skip to load data with data("data_example"))
tree = tree1(plot=T)$phylo.tree
symsim.param.zeisel = list(gene_effects_sd=2, sigma=0.2, scale_s=0.4, alpha_mean=0.5, alpha_sd=0.025,
depth_mean=2e5,depth_sd=1.5e4, nPCR1=14, prop_hge=0.01, mean_hge=3)
ngenes = 500
ncells = 500
truek = 8; min_popsize = floor(ncells/truek)
i_minpop =  which(tree$tip.label=='Microglia')
seed =  42
simu.out = generateDataSymSim(ncells=ncells, ngenes=ngenes, tree=tree,
params=symsim.param.zeisel, plot.tsne=T,
i_minpop=i_minpop, min_popsize=min_popsize,
nevf=150, n_de_evf=40, sigma=0.9, seed=seed)
simu.out$tsne_UMI_counts
# data_example = simu.out; usethis::use_data(data_example)
dat = simu.out
set.seed(42)
metadata = dat$metadata
rownames(metadata) = dat$metadata$cellid
ref.labels = dat$metadata$type
# alternatively and preferrably, we provide a sampling tool to sample resolution parameters to uniformly cover different scales
A = seurat_get_nn_graph(counts=dat$counts, metadata=metadata, npc=10)
resolutions = modularity_event_sampling(A=A, n.res=50, gamma.min=0.01, gamma.max=3) # sample based on the similarity matrix
# clustering using Suerat
seurat.out = sc_clustering.seurat(counts=dat$counts, resolutions=resolutions, metadata=metadata, npcs=10,
min.cells=0, min.features=0, scale.factor=10000, return.seurat.object=T,
vars.to.regress=NULL, find.variable.features=F, verbose=F)
# initial cluster tree from Seurat flat clustering
plot_clustree(labelmat=seurat.out$seurat.clusters, prefix ='RNA_snn_res.',
ref.labels = ref.labels, plot.ref = F)
out = mrtree(seurat.out$obj, consensus=F, augment.path=F)
plot_tree(labelmat=out$labelmat.mrtree, ref.labels=ref.labels, plot.piechart = T,
node.size = 0.4, tip.label.dist = 10, bottom.margin=30 )
ks.flat = apply(out$labelmat.flat, 2, FUN=function(x) length(unique(x)))
ks.mrtree = apply(out$labelmat.mrtree, 2, FUN=function(x) length(unique(x)))
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
ks.flat = apply(out$labelmat.flat, 2, FUN=function(x) length(unique(x)))
ks.mrtree = apply(out$labelmat.mrtree, 2, FUN=function(x) length(unique(x)))
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
ks.flat = apply(out$labelmat.flat, 2, FUN=function(x) length(unique(x)))
ks.mrtree = apply(out$labelmat.mrtree, 2, FUN=function(x) length(unique(x)))
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
amri.recon = sapply(1:ncol(out$labelmat.mrtree), function(i) AMRI(out$labelmat.mrtree[,i], ref.labels)$amri)
df = rbind(data.frame(k=amri.flat$k, amri=amri.flat$x, method='Seurat flat'),
data.frame(k=ks.mrtree, amri=amri.recon, method='MRtree'))
ggplot2::ggplot(data=df, aes(x=k, y=amri, color=method)) + geom_line() + theme_bw()
# alternatively and preferrably, we provide a sampling tool to sample resolution parameters to uniformly cover different scales
A = seurat_get_nn_graph(counts=dat$counts, metadata=metadata, npc=10)
resolutions = modularity_event_sampling(A=A, n.res=20, gamma.min=0.01, gamma.max=2) # sample based on the similarity matrix
resolutions = modularity_event_sampling(A=A, n.res=20, gamma.min=0.01, gamma.max=2) # sample based on the similarity matrix
# clustering using Suerat
seurat.out = sc_clustering.seurat(counts=dat$counts, resolutions=resolutions, metadata=metadata, npcs=10,
min.cells=0, min.features=0, scale.factor=10000, return.seurat.object=T,
vars.to.regress=NULL, find.variable.features=F, verbose=F)
# clustering using Suerat
seurat.out = sc_clustering.seurat(counts=dat$counts, resolutions=resolutions, metadata=metadata, npcs=10,
min.cells=0, min.features=0, scale.factor=10000, return.seurat.object=T,
vars.to.regress=NULL, find.variable.features=F, verbose=F)
# initial cluster tree from Seurat flat clustering
plot_clustree(labelmat=seurat.out$seurat.clusters, prefix ='RNA_snn_res.',
ref.labels = ref.labels, plot.ref = F)
out = mrtree(seurat.out$obj, consensus=F, augment.path=F)
plot_tree(labelmat=out$labelmat.mrtree, ref.labels=ref.labels, plot.piechart = T,
node.size = 0.4, tip.label.dist = 10, bottom.margin=30 )
ks.flat = apply(out$labelmat.flat, 2, FUN=function(x) length(unique(x)))
ks.mrtree = apply(out$labelmat.mrtree, 2, FUN=function(x) length(unique(x)))
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
amri.recon = sapply(1:ncol(out$labelmat.mrtree), function(i) AMRI(out$labelmat.mrtree[,i], ref.labels)$amri)
df = rbind(data.frame(k=amri.flat$k, amri=amri.flat$x, method='Seurat flat'),
data.frame(k=ks.mrtree, amri=amri.recon, method='MRtree'))
ggplot2::ggplot(data=df, aes(x=k, y=amri, color=method)) + geom_line() + theme_bw()
stab.out = stability_plot(out)
stab.out$plot
set.seed(42)
metadata = dat$metadata
rownames(metadata) = dat$metadata$cellid
ref.labels = dat$metadata$type
# alternatively and preferrably, we provide a sampling tool to sample resolution parameters to uniformly cover different scales
A = seurat_get_nn_graph(counts=dat$counts, metadata=metadata, npc=10)
resolutions = modularity_event_sampling(A=A, n.res=30, gamma.min=0.01, gamma.max=2.5) # sample based on the similarity matrix
resolutions = modularity_event_sampling(A=A, n.res=30, gamma.min=0.01, gamma.max=2.5) # sample based on the similarity matrix
# clustering using Suerat
seurat.out = sc_clustering.seurat(counts=dat$counts, resolutions=resolutions, metadata=metadata, npcs=10,
min.cells=0, min.features=0, scale.factor=10000, return.seurat.object=T,
vars.to.regress=NULL, find.variable.features=F, verbose=F)
resolutions = modularity_event_sampling(A=A, n.res=30, gamma.min=0.01, gamma.max=2.5) # sample based on the similarity matrix
# clustering using Suerat
seurat.out = sc_clustering.seurat(counts=dat$counts, resolutions=resolutions, metadata=metadata, npcs=10,
min.cells=0, min.features=0, scale.factor=10000, return.seurat.object=T,
vars.to.regress=NULL, find.variable.features=F, verbose=F)
# initial cluster tree from Seurat flat clustering
plot_clustree(labelmat=seurat.out$seurat.clusters, prefix ='RNA_snn_res.',
ref.labels = ref.labels, plot.ref = F)
out = mrtree(seurat.out$obj, consensus=F, augment.path=F)
plot_tree(labelmat=out$labelmat.mrtree, ref.labels=ref.labels, plot.piechart = T,
node.size = 0.4, tip.label.dist = 10, bottom.margin=30 )
ks.flat = apply(out$labelmat.flat, 2, FUN=function(x) length(unique(x)))
ks.mrtree = apply(out$labelmat.mrtree, 2, FUN=function(x) length(unique(x)))
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
amri.recon = sapply(1:ncol(out$labelmat.mrtree), function(i) AMRI(out$labelmat.mrtree[,i], ref.labels)$amri)
df = rbind(data.frame(k=amri.flat$k, amri=amri.flat$x, method='Seurat flat'),
data.frame(k=ks.mrtree, amri=amri.recon, method='MRtree'))
ggplot2::ggplot(data=df, aes(x=k, y=amri, color=method)) + geom_line() + theme_bw()
stab.out = stability_plot(out)
stab.out$plot
data_example = simu.out; usethis::use_data(data_example)
data_example = simu.out; usethis::use_data(data_example, overwrite = T)
help(guide_legend)
help(count.table)
help(cont.table)
installed.packages
installed.packages()
!'SIMLR' %in% installed.packages
!require('SIMLR', character.only = TRUE)
require('SIMLR', character.only = TRUE)
!require('SIMLR', character.only = TRUE)
help(ADPclust)
aricode::ARI()
aricode::ARI
help(aricode::ARI)
help(ARI)
#' A function to compute the adjusted rand index between two classifications.
#' Adjusted from aricode R package
#'
#' @param c1 a vector containing the labels of the first classification. Must be a vector of characters, integers, numerics, or a factor, but not a list.
#' @param c2 a vector containing the labels of the second classification.
#'
#' @return a scalar with the adjusted rand index.
ARI <- function (c1, c2)
{
res <- sortPairs(c1, c2)
N <- length(c1)
stot <- sum(choose(res$nij, 2), na.rm = TRUE)
srow <- sum(choose(res$ni., 2), na.rm = TRUE)
scol <- sum(choose(res$n.j, 2), na.rm = TRUE)
expectedIndex <- (srow * scol)/(choose(N, 2))
maximumIndex <- (srow + scol)/2
if (expectedIndex == maximumIndex & stot != 0) {
res <- 1
}
else {
res <- (stot - expectedIndex)/(maximumIndex - expectedIndex)
}
res
}
ARI(sample(10), sample(10))
help(sortPairs)
sortPairs()
sortPairs
aricode::sortPairs
help(Matrix)
help(expected_MI)
??expected_MI
help(hamming.distance)
hamming.distance
hamming.distance <- function(x,y){
z<-NULL
if(is.vector(x) && is.vector(y)){
z <- sum(x != y)
}
else{
z <- matrix(0,nrow=nrow(x),ncol=nrow(x))
for(k in 1:(nrow(x)-1)){
for(l in (k+1):nrow(x)){
z[k,l] <- hamming.distance(x[k,], x[l,])
z[l,k] <- z[k,l]
}
}
dimnames(z) <- list(dimnames(x)[[1]], dimnames(x)[[1]])
}
z
}
#' Hamming Distances of Vectors
#'
#' f both x and y are vectors, hamming.distance returns the Hamming distance (number of different elements) between this two vectors. If x is a matrix, the Hamming distances between the rows of x are computed and y is ignored.
#'
#' @param x a vector or matrix.
#' @param y an optional vector.
#'
#' @return distance matrix
hamming.distance <- function(x,y){
z<-NULL
if(is.vector(x) && is.vector(y)){
z <- sum(x != y)
} else {
z <- matrix(0,nrow=nrow(x),ncol=nrow(x))
for(k in 1:(nrow(x)-1)){
for(l in (k+1):nrow(x)){
z[k,l] <- hamming.distance(x[k,], x[l,])
z[l,k] <- z[k,l]
}
}
dimnames(z) <- list(dimnames(x)[[1]], dimnames(x)[[1]])
}
z
}
hamming.distance(sample(10), sample(10))
#' Sort Pairs
#'
#' A function to sort pairs of integers or factors and identify the pairs. The function is modified from aricode R package
#'
#' @param c1 a vector of length n with value between 0 and N1 < n
#' @param c2 a vector of length n with value between 0 and N2 < n
#' @param spMat logical: send back the contingency table as sparsely encoded (cost more than the algorithm itself). Default is FALSE
#' @import Matrix
#' @export
sortPairs <- function(c1, c2, spMat=FALSE){
if (anyNA(c1) | anyNA(c2))
stop("NA are not supported.")
if (((!is.vector(c1) & !is.factor(c1)) | is.list(c1)) | ((!is.vector(c2) & !is.factor(c2)) | is.list(c2)))
stop("c1 and c2 must be vectors or factors but not lists.")
if (length(c1) != length(c2))
stop("the two vectors must have the same length.")
n <- length(c1)
## if c1 and c2 are integer
if (is.integer(c1) & is.integer(c2)) {
## getRank is O(n) if max(c1)-min(c1) and max(c2)-min(c2) is of order length(c1)=length(c2)
## NOTE: getRank does not assume c1 and c2 are between 0 and n
res1 <- getRank(c1)
res2 <- getRank(c2)
mylevels <- list(c1=res1$index, c2=res2$index)
c1 <- res1$translated  # here ranks are in [0, n)
c2 <- res2$translated  # here ranks are in [0, n)
} else if (is.factor(c1) & is.factor(c2)) {
mylevels <- list(c1 = levels(c1), c2 = levels(c2))
c1 <- as.integer(c1) - 1L
c2 <- as.integer(c2) - 1L
} else {
## if neither a factor nor an integer or different of types force to factor then integer
mylevels <- list(c1 = unique(c1), c2 = unique(c2))
c1 <- as.integer(factor(c1, levels = mylevels$c1)) - 1L
c2 <- as.integer(factor(c2, levels = mylevels$c2)) - 1L
}
i_order <- order(c1, c2, method="radix") - 1L
out <- countPairs(c1, c2, i_order)
if (spMat) {
spOut <- sparseMatrix(i=out$pair_c1,
j=out$pair_c2,
x=out$pair_nb,
dims=sapply(mylevels,length),
dimnames = mylevels, index1=FALSE)
} else {
spOut <- NULL
}
res <- list(spMat = spOut,
levels = mylevels,
nij = out$pair_nb,
ni. = out$c1_nb,
n.j = out$c2_nb,
pair_c1 = out$pair_c1,
pair_c2 = out$pair_c2
)
res
}
#' Adjusted Rand Index, adopted from aricode R package
#'
#' A function to compute the adjusted rand index between two classifications. The function is modified from aricode R package
#'
#' @param c1 a vector containing the labels of the first classification. Must be a vector of characters, integers, numerics, or a factor, but not a list.
#' @param c2 a vector containing the labels of the second classification.
#' @return a scalar with the adjusted rand index.
#' @export
ARI <- function(c1, c2){
## get pairs using C
## ensure that values of c1 and c2 are between 0 and n1
res <- sortPairs(c1, c2)
## get ARI using pairs
N <- length(c1)
stot <- sum(choose(res$nij, 2), na.rm=TRUE)
srow <- sum(choose(res$ni., 2), na.rm=TRUE)
scol <- sum(choose(res$n.j, 2), na.rm=TRUE)
expectedIndex <-(srow*scol)/(choose(N,2))
maximumIndex <- (srow+scol)/2
if (expectedIndex == maximumIndex & stot != 0) {
res <- 1
} else {
res <- (stot-expectedIndex)/(maximumIndex-expectedIndex)
}
res
}
ARI(sample(10), sample(10))
adjustedRandIndex <- function (x, y)
{
x <- as.vector(x)
y <- as.vector(y)
if(length(x) != length(y))
stop("arguments must be vectors of the same length")
tab <- table(x,y)
if(all(dim(tab)==c(1,1))) return(1)
a <- sum(choose(tab, 2))
b <- sum(choose(rowSums(tab), 2)) - a
c <- sum(choose(colSums(tab), 2)) - a
d <- choose(sum(tab), 2) - a - b - c
ARI <- (a - (a + b) * (a + c)/(a + b + c + d)) /
((a + b + a + c)/2 - (a + b) * (a + c)/(a + b + c + d))
return(ARI)
}
adjustedRandIndex(sample(100), sample(100))
adjustedRandIndex(sample(1:4, 100, replace = T), sample(1:4, 100, replace = T))
tmp1 = sample(1:4, 100, replace = T)
tmp2 = sample(1:4, 100, replace = T)
adjustedRandIndex(tmp1, tmp2)
aricode::ARI(tmp1, tmp2)
tmp1 = sample(1:4, 100, replace = T)
tmp2 = sample(1:5, 100, replace = T)
aricode::ARI(tmp1, tmp2)
adjustedRandIndex(tmp1, tmp2)
useMart
!require('biomaRt', character.only = TRUE)
as_tibble
tibble::as_tibble
'ADPclust' %in% installed.packages()
require(SymSim)
require(SymSim, quietly = T)
!"Seurat" %in% installed.packages()
!require(Seurat, quietly = T)
help(as_tibble)
build()
formatR::tidy_dir("R")
formatR::tidy_dir("R")
formatR::tidy_dir("R")
formatR::tidy_dir("R")
formatR::tidy_dir("R")
formatR::tidy_dir("R")
formatR::tidy_dir("R")
formatR::tidy_dir("R")
formatR::tidy_dir("R")
formatR::tidy_dir("R")
help(tidy_dir)
tmp = '        sigma = sigma, geffect_mean = geffect_mean, gene_effects_sd = gene_effects_sd, gene_effect_prob = gene_effect_prob, bimod = bimod, param_realdata = param_realdata,'
nchar(tmp)
options(width=80)
options()$width
