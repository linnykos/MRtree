out = mrtree(labelmat, max.k=Inf, consensus= Inf, sample.weighted=F, verbose=T)
devtools::load_all()
# consensus = F
# sample.weighted = F
# max.k = Inf
out = mrtree(labelmat, max.k=Inf, consensus= Inf, sample.weighted=F, verbose=T)
devtools::load_all()
# consensus = F
# sample.weighted = F
# max.k = Inf
out = mrtree(labelmat, max.k=Inf, consensus= Inf, sample.weighted=F, verbose=T)
#####################
# results
plot_clustree(labelmat, prefix ='col', cell.type = NULL, plot.labels = F)
plot_clustree(out$labelmat.recon, prefix ='col', cell.type = NULL, plot.labels = F)
plot_clustree(out$labelmat.flat, prefix ='col', cell.type = NULL, plot.labels = F)
plot_clustree(out$labelmat.recon, prefix ='col', cell.type = NULL, plot.labels = F)
# consensus = F
# sample.weighted = F
# max.k = Inf
out = mrtree(labelmat, max.k=Inf, consensus= Inf, sample.weighted=F, verbose=F)
#####################
# results
plot_clustree(labelmat, prefix ='col', cell.type = NULL, plot.labels = F)
plot_clustree(out$labelmat.recon, prefix ='col', cell.type = NULL, plot.labels = F)
# consensus = F
# sample.weighted = F
# max.k = Inf
out = mrtree(labelmat, max.k=Inf, consensus= Inf, sample.weighted=F, verbose=F)
plot_clustree(out$labelmat.recon, prefix ='col', cell.type = NULL, plot.labels = F)
# consensus = F
# sample.weighted = F
# max.k = Inf
out = mrtree(labelmat, max.k=Inf, consensus=F sample.weighted=F, verbose=F)
# consensus = F
# sample.weighted = F
# max.k = Inf
out = mrtree(labelmat, max.k=Inf, consensus=F, sample.weighted=F, verbose=F)
devtools::load_all()
labelmat = matrix(NA, nrow=200, ncol=7)
labelmat[1:100,1] = 1; labelmat[101:200,1] = 2
labelmat[1:50, 2] = 1; labelmat[51:100, 2] = 2; labelmat[101:200, 2] = 3
labelmat[1:50, 3] = 1; labelmat[51:100, 3] = 2; labelmat[101:200, 3] = 3
labelmat[1:100,4] = 1;  labelmat[101:150, 4] = 2;  labelmat[151:200, 4] = 3
labelmat[1:50, 5] = 1; labelmat[51:100, 5] = 2; labelmat[101:200, 5] = 3
labelmat[1:50, 6] = 1; labelmat[51:100, 6] = 2; labelmat[101:200, 6] = 3
labelmat[1:50, 7] = 1; labelmat[51:100, 7] = 2;  labelmat[101:150, 7] = 3; labelmat[151:200, 7] = 4
colnames(labelmat) = paste0('col', 1:7)
# consensus = F
# sample.weighted = F
# max.k = Inf
out = mrtree(labelmat, max.k=Inf, consensus=F, sample.weighted=F, verbose=F)
#####################
# results
plot_clustree(labelmat, prefix ='col', cell.type = NULL, plot.labels = F)
q
qui()
quit()
rm(list = ls())
devtools::load_all()
devtools::load_all()
labelmat = matrix(NA, nrow=200, ncol=7)
labelmat[1:100,1] = 1; labelmat[101:200,1] = 2
labelmat[1:50, 2] = 1; labelmat[51:100, 2] = 2; labelmat[101:200, 2] = 3
labelmat[1:50, 3] = 1; labelmat[51:100, 3] = 2; labelmat[101:200, 3] = 3
labelmat[1:100,4] = 1;  labelmat[101:150, 4] = 2;  labelmat[151:200, 4] = 3
labelmat[1:50, 5] = 1; labelmat[51:100, 5] = 2; labelmat[101:200, 5] = 3
labelmat[1:50, 6] = 1; labelmat[51:100, 6] = 2; labelmat[101:200, 6] = 3
labelmat[1:50, 7] = 1; labelmat[51:100, 7] = 2;  labelmat[101:150, 7] = 3; labelmat[151:200, 7] = 4
colnames(labelmat) = paste0('col', 1:7)
# consensus = F
# sample.weighted = F
# max.k = Inf
out = mrtree(labelmat, max.k=Inf, consensus=F, sample.weighted=F, verbose=F)
devtools::load_all()
devtools::load_all()
labelmat = matrix(NA, nrow=200, ncol=7)
devtools::document()
devtools::load_all()
devtools::load_all()
code.path = 'R/realdata/'
out.path = 'R/realdata/results_zeisel/'
data.path = '../../../SingleCell/data/'
load(paste0(data.path, 'zeisel/processed/zeisel.RData'))
counts = t(zeisel$counts)
true.labels = zeisel$cell.info$level1class
# table(true.labels)
true.labels=plyr::mapvalues(true.labels,
from=c('astrocytes_ependymal', 'endothelial-mural','interneurons','microglia',
'oligodendrocytes','pyramidal CA1','pyramidal SS'),
to = c('astrocytes', 'end','inhibitary','microglia','oligo','excitotary CA1','excitotary SS'))
metadata = zeisel$cell.info
counts = t(zeisel$counts)
rownames(metadata) = colnames(counts)
devtools::load_all()
suffix = '_simu_01'
result.path = 'R/simulations/results/'
#####################
sigma = 0.7; sigma_name='07' # SimSym parameter, within cluster variation, the smaller the more separated of the clusters
nrep = 50; nrep_stab = 10; n.cores = 10
kmax = 10; ks = 2:kmax
resolutions = seq(0,3,0.2)
index.name = 'amri'
subsample_prop = 0.9 # subsample 90% for stability
tree.out = tree1(plot=F)
tree = tree.out$phylo.tree
symsim.param.zeisel = list(gene_effects_sd=2, sigma=0.2, scale_s=0.4, alpha_mean=0.5, alpha_sd=0.025,
depth_mean=2e5,depth_sd=1.5e4, nPCR1=14, prop_hge=0.01, mean_hge=3)
nevf = 60
n_de_evf = 30
ncells = 500
ngenes = 500
truek = 8
min_popsize = floor(ncells/truek)
## visualize the results
res = readRDS(paste0(result.path, 'out_seurat_sigma', sigma_name, suffix,'.rds'))
acc.flat = do.call(cbind, lapply(res, function(x)  x$acc$flat))
acc.mrtree = do.call(cbind, lapply(res, function(x) x$acc$mrtree))
df = rbind(data.frame(acc = c(acc.flat), k = rep(ks, nrep), method='Seurat'),
data.frame(acc = c(acc.mrtree), k = rep(ks, nrep), method='MrTree'))
df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = acc, fill = method)) + geom_boxplot()+ylab('AMRI') +theme(text = element_text(size=20))+ylim(0.8,1)
# compare the tree reconstruction accuracy
df = data.frame(tree.diff = c(
# sapply(res, function(x) x$tree.diff$flat),
sapply(res, function(x) x$tree.diff$mrtree),
sapply(res, function(x) x$tree.diff$hc)),
method = rep(c('MrTree', paste0('Seurat HAC')), each = nrep))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = acc, fill = method)) + geom_boxplot()+ylab('AMRI') +theme(text = element_text(size=20))+ylim(0.8,1)
# compare the tree reconstruction accuracy
df = data.frame(tree.diff = c(
# sapply(res, function(x) x$tree.diff$flat),
sapply(res, function(x) x$tree.diff$mrtree),
sapply(res, function(x) x$tree.diff$hc)),
method = rep(c('MrTree', paste0('Seurat HAC')), each = nrep))
options(repr.plot.width = 4, repr.plot.height = 3)
ggplot(df, aes(x = method, y=tree.diff)) + geom_boxplot()+ylab('Error') +ylim(0,0.4)
set.seed(42)
simu.out = parallel::mclapply(1:nrep, function(iter){
logmsg('------------------\nRun simulation repeat ', iter,':')
logmsg('Generate data ...')
dat = generateDataSymSim(ncells=ncells, ngenes=ngenes,
tree=tree, params=symsim.param.zeisel,
nevf = nevf, n_de_evf = n_de_evf, sigma=sigma,
i_minpop=which(tree$tip.label=='Microglia'),
min_popsize=min_popsize, plot.tsne = F, seed=iter)
counts = dat$counts
metadata = dat$metadata
# sample resolutons
A = seurat_get_nn_graph(counts=counts, metadata=metadata, npc=npcs)
resolutions = modularity_event_sampling(A=A, n.res=n.res, gamma.min=0.01, gamma.max=3)
# Seurat clustering
clust.out = sc_clustering.seurat(counts = counts, resolutions = resolutions, metadata = metadata,
find.variable.features = F, npcs=npcs, seurat.graph.algorithm = 1,
build.hierarchical.tree = T, return.seurat.object = T)
out = mrtree(clust.out$obj, prefix='RNA_snn_res.',
max.k=max.k, consensus=consensus, sample.weighted=sample.weighted, verbose=F)
# calculate the metrics
acc = data.frame(flat = rep(NA, length(ks)), mrtree = rep(NA, length(ks)),
sim = rep(NA, length(ks)), row.names = as.character(ks))
tree.diff = list()
ks.flat = apply(out$labelmat.flat, 2, function(x) length(unique(x)))
ks.mrtree = apply(out$labelmat.mrtree, 2, function(x) length(unique(x)))
# clustering accuracy for original flat clustering
# flat
logmsg('Clustering accuracy ...')
res = aggregate(get_index_per_layer(labelmat1 = out$labelmat.flat,
labelmat2 = metadata$type,
index.name=index.name),
by=list(k=ks.flat), FUN=mean, na.rm=T)
res = res[res$k %in% ks, ]
acc[as.character(res$k),'flat'] = res$x
# mrtree
res = aggregate( get_index_per_layer(labelmat1 = out$labelmat.mrtree,
labelmat2 = metadata$type,
index.name=index.name),
by=list(k=ks.mrtree), FUN=mean, na.rm=T)
res = res[res$k %in% ks, ]
acc[as.character(res$k),'mrtree'] = res$x
# measure the difference of before and after tree reconciliation
logmsg('Tree cuts ...')
res = aggregate( get_index_per_layer(labelmat1 = out$labelmat.flat,
labelmat2 = out$labelmat.recon,
index.name='ari'),
by=list(k=ks.flat), FUN=max, na.rm=T) # take the maximum
res = res[res$k %in% ks, ]
acc[as.character(res$k),'sim'] = res$x
# calculate the similarity matrix from a phylo tree and sample labels
logmsg('Tree estimation accuracy ...')
sim.mat.true = get_similarity_from_tree(tree=tree, labels=dat$metadata$type)
sim.mat.flat = get_similarity_from_labelmat(labelmat=out$labelmat.flat)
sim.mat.mrtree = get_similarity_from_labelmat(labelmat=out$labelmat.mrtree)
sim.mat.hc = get_similarity_from_tree(tree=clust.out$hc.tree,
labels=as.character(clust.out$hc.tree$sample.labels)) #labels=as.character(clust.out$obj[['seurat_clusters']][,1]))
tree.diff$flat = diff_between_similarity_mat(sim.mat.true, sim.mat.flat)
tree.diff$mrtree = diff_between_similarity_mat(sim.mat.true, sim.mat.mrtree)
tree.diff$hc = diff_between_similarity_mat(sim.mat.true, sim.mat.hc)
# clustering stability
logmsg('Clustering stability ...')
nb_sample = ncol(counts)
stab.out = lapply(1:nrep_stab, function(iter_stab){
logmsg('-- Subsample iteration ',iter_stab,':')
subsample_ind = sample(1:nb_sample, nb_sample*subsample_prop, replace=F)
counts.i = counts[,subsample_ind]
colnames(counts.i) = paste0('cell_',1:length(subsample_ind))
metadata.i = metadata[subsample_ind,]
rownames(metadata.i) = paste0('cell_',1:length(subsample_ind))
clust.out.i = sc_clustering.seurat(counts=counts.i, resolutions=resolutions, metadata=metadata.i,
find.variable.features = F, npcs=npcs, seurat.graph.algorithm = 1)
out.i = mrtree(clust.out.i$seurat.clusters, prefix='RNA_snn_res.',
max.k=max.k, consensus=consensus, sample.weighted=sample.weighted, verbose=F)
res = aggregate(get_index_per_layer(out.i$labelmat.flat,
out$labelmat.flat[subsample_ind,],
index.name='ari'),
by=list(k=ks.flat), FUN=mean)
stab.flat = rep(NA, length(ks)); names(stab.flat) = as.character(ks)
res = res[res$k %in% ks, ]
stab.flat[as.character(res$k)] = res$x
# compare the clusters in the tree with the bootstrap results
labelmat.tree.i = out.i$labelmat.mrtree; colnames(labelmat.tree.i) = apply(labelmat.tree.i, 2, function(y) length(unique(y)))
labelmat.tree = out$labelmat.mrtree[subsample_ind,]; colnames(labelmat.tree) = ks.mrtree
labelmat.tree_col = intersect(colnames(labelmat.tree.i), colnames(labelmat.tree))
labelmat.tree_col = labelmat.tree_col[as.numeric(labelmat.tree_col) %in% ks]
stab.tree = rep(NA, length(ks)); names(stab.tree) = as.character(ks)
stab.tree[labelmat.tree_col] = get_index_per_layer(labelmat1 = labelmat.tree.i[,labelmat.tree_col],
labelmat2 = labelmat.tree[,labelmat.tree_col], index.name='ari')
return(list(stab.flat=stab.flat, stab.tree=stab.tree))
})
stab.flat = colMeans(do.call(rbind,lapply(stab.out, function(x) x$stab.flat)))
stab.mrtree = colMeans(do.call(rbind,lapply(stab.out, function(x) x$stab.tree)))
stab = data.frame(flat = stab.flat, mrtree = stab.mrtree)
return(list(acc=acc, tree.diff=tree.diff, stab = stab))
},mc.cores = n.cores) #
## visualize the results
res = readRDS(paste0(result.path, 'out_seurat_sigma', sigma_name, suffix,'.rds'))
acc.flat = do.call(cbind, lapply(res, function(x)  x$acc$flat))
acc.mrtree = do.call(cbind, lapply(res, function(x) x$acc$mrtree))
df = rbind(data.frame(acc = c(acc.flat), k = rep(ks, nrep), method='Seurat'),
data.frame(acc = c(acc.mrtree), k = rep(ks, nrep), method='MrTree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = acc, fill = method)) + geom_boxplot()+ylab('AMRI') +theme(text = element_text(size=20))+ylim(0.8,1)
# compare the tree reconstruction accuracy
df = data.frame(tree.diff = c(
# sapply(res, function(x) x$tree.diff$flat),
sapply(res, function(x) x$tree.diff$mrtree),
sapply(res, function(x) x$tree.diff$hc)),
method = rep(c('MrTree', paste0('Seurat HAC')), each = nrep))
options(repr.plot.width = 4, repr.plot.height = 3)
ggplot(df, aes(x = method, y=tree.diff)) + geom_boxplot()+ylab('Error') +ylim(0,0.4)
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$kway))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$recon))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='Seurat'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$flat))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$recon))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='Seurat'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
str(stab.flat)
str(stab.mrtree)
str(res)
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$mrtree))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='Seurat'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = stab, fill = method)) + geom_boxplot()+ylab('Stability v.s. true label')  #+ylim(0.2,1)
## visualize the results
res = readRDS(paste0(result.path, 'out_sc3_sigma', sigma_name, suffix,'.rds'))
acc.flat = do.call(cbind, lapply(res, function(x)  x$acc$flat))
acc.mrtree = do.call(cbind, lapply(res, function(x) x$acc$mrtree))
df = rbind(data.frame(acc = c(acc.flat), k = rep(ks, nrep), method='Seurat'),
data.frame(acc = c(acc.mrtree), k = rep(ks, nrep), method='MrTree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = acc, fill = method)) + geom_boxplot()+ylab('AMRI') +theme(text = element_text(size=20))+ylim(0.8,1)
# compare the tree reconstruction accuracy
df = data.frame(tree.diff = c(
# sapply(res, function(x) x$tree.diff$flat),
sapply(res, function(x) x$tree.diff$mrtree),
sapply(res, function(x) x$tree.diff$hc)),
method = rep(c('MrTree', paste0('SC3 HAC')), each = nrep))
options(repr.plot.width = 4, repr.plot.height = 3)
ggplot(df, aes(x = method, y=tree.diff)) + geom_boxplot()+ylab('Error') +ylim(0,0.4)
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$kway))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$recon))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='SC3'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$flat))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$mrtree))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='SC3'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = stab, fill = method)) + geom_boxplot()+ylab('Stability v.s. true label')  #+ylim(0.2,1)
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='SC3'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = stab, fill = method)) + geom_boxplot()+ylab('Stability v.s. true label')  #+ylim(0.2,1)
## visualize the results
res = readRDS(paste0(result.path, 'out_umapkmeans_sigma', sigma_name, suffix,'.rds'))
acc.flat = do.call(cbind, lapply(res, function(x)  x$acc$flat))
acc.mrtree = do.call(cbind, lapply(res, function(x) x$acc$mrtree))
df = rbind(data.frame(acc = c(acc.flat), k = rep(ks, nrep), method='UMAP+Kmeans'),
data.frame(acc = c(acc.mrtree), k = rep(ks, nrep), method='MrTree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = acc, fill = method)) + geom_boxplot()+ylab('AMRI') +theme(text = element_text(size=20))+ylim(0.8,1)
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$flat))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$mrtree))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='UMAP+Kmeans'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
df =df[df$k <=8,]
df$k = as.factor(df$k)
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = stab, fill = method)) + geom_boxplot()+ylab('Stability v.s. true label')  #+ylim(0.2,1)
## visualize the results
res = readRDS(paste0(result.path, 'out_soup_sigma', sigma_name, suffix,'.rds'))
acc.flat = do.call(cbind, lapply(res, function(x)  x$acc$flat))
acc.mrtree = do.call(cbind, lapply(res, function(x) x$acc$mrtree))
df = rbind(data.frame(acc = c(acc.flat), k = rep(ks, nrep), method='SOUP'),
data.frame(acc = c(acc.mrtree), k = rep(ks, nrep), method='MrTree'))
# df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = acc, fill = method)) + geom_boxplot()+ylab('AMRI') +theme(text = element_text(size=20))+ylim(0.8,1)
# stability
stab.flat = do.call(cbind, lapply(res, function(x)  x$stab$flat))
stab.mrtree = do.call(cbind, lapply(res, function(x) x$stab$mrtree))
df = rbind(data.frame(stab = c(stab.flat), k = rep(ks, nrep), method='SOUP'),
data.frame(stab = c(stab.mrtree), k = rep(ks, nrep), method='MRtree'))
df =df[df$k <=8,]
df$k = as.factor(df$k)
options(repr.plot.width = 6, repr.plot.height = 5)
ggplot(df, aes(x = k, y = stab, fill = method)) + geom_boxplot()+ylab('Stability v.s. true label')  #+ylim(0.2,1)
devtools::load_all()
labelmat = matrix(NA, nrow=200, ncol=7)
labelmat[1:100,1] = 1; labelmat[101:200,1] = 2
labelmat[1:50, 2] = 1; labelmat[51:100, 2] = 2; labelmat[101:200, 2] = 3
labelmat[1:50, 3] = 1; labelmat[51:100, 3] = 2; labelmat[101:200, 3] = 3
labelmat[1:100,4] = 1;  labelmat[101:150, 4] = 2;  labelmat[151:200, 4] = 3
labelmat[1:50, 5] = 1; labelmat[51:100, 5] = 2; labelmat[101:200, 5] = 3
labelmat[1:50, 6] = 1; labelmat[51:100, 6] = 2; labelmat[101:200, 6] = 3
labelmat[1:50, 7] = 1; labelmat[51:100, 7] = 2;  labelmat[101:150, 7] = 3; labelmat[151:200, 7] = 4
colnames(labelmat) = paste0('col', 1:7)
out = mrtree(labelmat, max.k=Inf, consensus=F, sample.weighted=F, verbose=F)
#####################
# results
plot_clustree(labelmat, prefix ='col', cell.type = NULL, plot.labels = F)
plot_clustree(out$labelmat.recon, prefix ='col', cell.type = NULL, plot.labels = F)
#####################
# results
plot_clustree(labelmat, prefix ='col', cell.type = NULL, plot.labels = F)
plot_clustree(out$labelmat.recon, prefix ='col', cell.type = NULL, plot.labels = F)
out = mrtree(labelmat, max.k=Inf, aug.path=T, consensus=F, sample.weighted=F, verbose=F)
out = mrtree(labelmat, max.k=Inf, augment.path = T, consensus=F, sample.weighted=F, verbose=F)
#####################
# results
plot_clustree(labelmat, prefix ='col', cell.type = NULL, plot.labels = F)
plot_clustree(out$labelmat.recon, prefix ='col', cell.type = NULL, plot.labels = F)
paste0(result.path, 'out_seurat_sigma', sigma_name, suffix,'.rds')
source('~/Dropbox/research/MRtree/code/mrtree/R/simulations/simulation2.R', echo=TRUE)
paste0(result.path, 'out_seurat_sigma', sigma_name, suffix,'.rds')
realdata_geschwind_label_results <- readRDS("~/Dropbox/research/MRtree/code/analysis/realdata/results-geschwind/realdata_geschwind_label_results.rds")
str(realdata_geschwind_label_results)
getwd()
write.xlsx(realdata_geschwind_label_results, 'fetal_brain_labels.xlsx', sheetName = "Sheet1",
col.names = TRUE, row.names = TRUE, append = FALSE)
xlsx::write.xlsx(realdata_geschwind_label_results, 'fetal_brain_labels.xlsx', sheetName = "Sheet1",
col.names = TRUE, row.names = TRUE, append = FALSE)
xlsx::write.xlsx2(realdata_geschwind_label_results, 'fetal_brain_labels.xlsx', sheetName = "Sheet1",
col.names = TRUE, row.names = TRUE, append = FALSE)
write.table(realdata_geschwind_label_results, 'fetal_brain_labels.xlsx')
install.packages("writexl")
writexl::write_xlsx(realdata_geschwind_label_results,"fetal_brain_labels.xlsx")
devtools::load_all()
# The data simulation can be performed using SymSim package with the following wrapper function,
# The following simulation code take some time to run (skip to load data with data("data_example"))
tree = tree1(plot=T)$phylo.tree
symsim.param.zeisel = list(gene_effects_sd=2, sigma=0.2, scale_s=0.4, alpha_mean=0.5, alpha_sd=0.025,
depth_mean=2e5,depth_sd=1.5e4, nPCR1=14, prop_hge=0.01, mean_hge=3)
ngenes = 500
ncells = 500
truek = 8; min_popsize = floor(ncells/truek)
i_minpop =  which(tree$tip.label=='Microglia')
seed =  42
simu.out = generateDataSymSim(ncells=ncells, ngenes=ngenes, tree=tree,
params=symsim.param.zeisel, plot.tsne=T,
i_minpop=i_minpop, min_popsize=min_popsize,
nevf=150, n_de_evf=40, sigma=0.9, seed=seed)
simu.out$tsne_UMI_counts
# data_example = simu.out; usethis::use_data(data_example)
dat = simu.out
set.seed(42)
metadata = dat$metadata
rownames(metadata) = dat$metadata$cellid
ref.labels = dat$metadata$type
# alternatively and preferrably, we provide a sampling tool to sample resolution parameters to uniformly cover different scales
A = seurat_get_nn_graph(counts=dat$counts, metadata=metadata, npc=10)
resolutions = modularity_event_sampling(A=A, n.res=50, gamma.min=0.01, gamma.max=3) # sample based on the similarity matrix
# clustering using Suerat
seurat.out = sc_clustering.seurat(counts=dat$counts, resolutions=resolutions, metadata=metadata, npcs=10,
min.cells=0, min.features=0, scale.factor=10000, return.seurat.object=T,
vars.to.regress=NULL, find.variable.features=F, verbose=F)
# initial cluster tree from Seurat flat clustering
plot_clustree(labelmat=seurat.out$seurat.clusters, prefix ='RNA_snn_res.',
ref.labels = ref.labels, plot.ref = F)
out = mrtree(seurat.out$obj, consensus=F, augment.path=F)
plot_tree(labelmat=out$labelmat.mrtree, ref.labels=ref.labels, plot.piechart = T,
node.size = 0.4, tip.label.dist = 10, bottom.margin=30 )
ks.flat = apply(out$labelmat.flat, 2, FUN=function(x) length(unique(x)))
ks.mrtree = apply(out$labelmat.mrtree, 2, FUN=function(x) length(unique(x)))
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
ks.flat = apply(out$labelmat.flat, 2, FUN=function(x) length(unique(x)))
ks.mrtree = apply(out$labelmat.mrtree, 2, FUN=function(x) length(unique(x)))
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
ks.flat = apply(out$labelmat.flat, 2, FUN=function(x) length(unique(x)))
ks.mrtree = apply(out$labelmat.mrtree, 2, FUN=function(x) length(unique(x)))
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
amri.recon = sapply(1:ncol(out$labelmat.mrtree), function(i) AMRI(out$labelmat.mrtree[,i], ref.labels)$amri)
df = rbind(data.frame(k=amri.flat$k, amri=amri.flat$x, method='Seurat flat'),
data.frame(k=ks.mrtree, amri=amri.recon, method='MRtree'))
ggplot2::ggplot(data=df, aes(x=k, y=amri, color=method)) + geom_line() + theme_bw()
# alternatively and preferrably, we provide a sampling tool to sample resolution parameters to uniformly cover different scales
A = seurat_get_nn_graph(counts=dat$counts, metadata=metadata, npc=10)
resolutions = modularity_event_sampling(A=A, n.res=20, gamma.min=0.01, gamma.max=2) # sample based on the similarity matrix
resolutions = modularity_event_sampling(A=A, n.res=20, gamma.min=0.01, gamma.max=2) # sample based on the similarity matrix
# clustering using Suerat
seurat.out = sc_clustering.seurat(counts=dat$counts, resolutions=resolutions, metadata=metadata, npcs=10,
min.cells=0, min.features=0, scale.factor=10000, return.seurat.object=T,
vars.to.regress=NULL, find.variable.features=F, verbose=F)
# clustering using Suerat
seurat.out = sc_clustering.seurat(counts=dat$counts, resolutions=resolutions, metadata=metadata, npcs=10,
min.cells=0, min.features=0, scale.factor=10000, return.seurat.object=T,
vars.to.regress=NULL, find.variable.features=F, verbose=F)
# initial cluster tree from Seurat flat clustering
plot_clustree(labelmat=seurat.out$seurat.clusters, prefix ='RNA_snn_res.',
ref.labels = ref.labels, plot.ref = F)
out = mrtree(seurat.out$obj, consensus=F, augment.path=F)
plot_tree(labelmat=out$labelmat.mrtree, ref.labels=ref.labels, plot.piechart = T,
node.size = 0.4, tip.label.dist = 10, bottom.margin=30 )
ks.flat = apply(out$labelmat.flat, 2, FUN=function(x) length(unique(x)))
ks.mrtree = apply(out$labelmat.mrtree, 2, FUN=function(x) length(unique(x)))
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
amri.recon = sapply(1:ncol(out$labelmat.mrtree), function(i) AMRI(out$labelmat.mrtree[,i], ref.labels)$amri)
df = rbind(data.frame(k=amri.flat$k, amri=amri.flat$x, method='Seurat flat'),
data.frame(k=ks.mrtree, amri=amri.recon, method='MRtree'))
ggplot2::ggplot(data=df, aes(x=k, y=amri, color=method)) + geom_line() + theme_bw()
stab.out = stability_plot(out)
stab.out$plot
set.seed(42)
metadata = dat$metadata
rownames(metadata) = dat$metadata$cellid
ref.labels = dat$metadata$type
# alternatively and preferrably, we provide a sampling tool to sample resolution parameters to uniformly cover different scales
A = seurat_get_nn_graph(counts=dat$counts, metadata=metadata, npc=10)
resolutions = modularity_event_sampling(A=A, n.res=30, gamma.min=0.01, gamma.max=2.5) # sample based on the similarity matrix
resolutions = modularity_event_sampling(A=A, n.res=30, gamma.min=0.01, gamma.max=2.5) # sample based on the similarity matrix
# clustering using Suerat
seurat.out = sc_clustering.seurat(counts=dat$counts, resolutions=resolutions, metadata=metadata, npcs=10,
min.cells=0, min.features=0, scale.factor=10000, return.seurat.object=T,
vars.to.regress=NULL, find.variable.features=F, verbose=F)
resolutions = modularity_event_sampling(A=A, n.res=30, gamma.min=0.01, gamma.max=2.5) # sample based on the similarity matrix
# clustering using Suerat
seurat.out = sc_clustering.seurat(counts=dat$counts, resolutions=resolutions, metadata=metadata, npcs=10,
min.cells=0, min.features=0, scale.factor=10000, return.seurat.object=T,
vars.to.regress=NULL, find.variable.features=F, verbose=F)
# initial cluster tree from Seurat flat clustering
plot_clustree(labelmat=seurat.out$seurat.clusters, prefix ='RNA_snn_res.',
ref.labels = ref.labels, plot.ref = F)
out = mrtree(seurat.out$obj, consensus=F, augment.path=F)
plot_tree(labelmat=out$labelmat.mrtree, ref.labels=ref.labels, plot.piechart = T,
node.size = 0.4, tip.label.dist = 10, bottom.margin=30 )
ks.flat = apply(out$labelmat.flat, 2, FUN=function(x) length(unique(x)))
ks.mrtree = apply(out$labelmat.mrtree, 2, FUN=function(x) length(unique(x)))
amri.flat = sapply(1:ncol(out$labelmat.flat), function(i) AMRI(out$labelmat.flat[,i], ref.labels)$amri)
amri.flat = aggregate(amri.flat, by=list(k=ks.flat), FUN=mean)
amri.recon = sapply(1:ncol(out$labelmat.mrtree), function(i) AMRI(out$labelmat.mrtree[,i], ref.labels)$amri)
df = rbind(data.frame(k=amri.flat$k, amri=amri.flat$x, method='Seurat flat'),
data.frame(k=ks.mrtree, amri=amri.recon, method='MRtree'))
ggplot2::ggplot(data=df, aes(x=k, y=amri, color=method)) + geom_line() + theme_bw()
stab.out = stability_plot(out)
stab.out$plot
data_example = simu.out; usethis::use_data(data_example)
data_example = simu.out; usethis::use_data(data_example, overwrite = T)
